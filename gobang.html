<!DOCTYPE html>

<html>

<head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta content="always" name="referrer">
    <meta name="theme-color" content="#2932e1">
    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
    <title>人机对战-五子棋</title>

    <style type="text/css" index="weather">
        #app {
            display: flex
        }

        .chess {
            width: 800px;
            height: 800px;
        }
    </style>
</head>

<body>
    <div id="app">
        <div class="chess">
            <canvas ref="canvas"></canvas>
        </div>
    </div>

    <script type="text/javascript">
        class Game {
            constructor(dom) {
                this.dom = dom;
                this.player = 1;
                this.DIMENSION = 12;
                this.SIZE = 60;
                this.QIZI = 20

                let board = [];
                for (let i = 0; i <= this.DIMENSION; i++) {
                    let row = [];
                    for (let j = 0; j <= this.DIMENSION; j++) {
                        row.push(0);
                    }
                    board.push(row)
                }
                this.board = board;
                this.gameOver = false;
                this.state = board.slice(0);

                this.initCanvas(dom);
                this.eventHandle(dom);
            }

            initCanvas(dom) {
                const canvas = dom;
                const parent = canvas.parentNode;
                this.context = canvas.getContext('2d');
                const devicePixelRatio = window.devicePixelRatio || 1;
                const backingStoreRatio =
                    this.context.webkitBackingStorePixelRatio ||
                    this.context.mozBackingStorePixelRatio ||
                    this.context.msBackingStorePixelRatio ||
                    this.context.oBackingStorePixelRatio ||
                    this.context.backingStorePixelRatio ||
                    1;
                const ratio = devicePixelRatio / backingStoreRatio;
                this.ratio = ratio;

                const rect = parent.getBoundingClientRect();
                this.width = rect.width;
                this.height = rect.height;
                canvas.style.width = rect.width + "px";
                canvas.style.height = rect.height + "px";

                canvas.width = rect.width * this.ratio;
                canvas.height = rect.height * this.ratio;
                this.context.scale(this.ratio, this.ratio);
                this.context.lineWidth = 2;
                this.context.strokeStyle = '#cccccc';
                this.context.fillStyle = 'coral';
                this.context.lineJoin = 'round';
                this.context.font = '16px sans-serif';
                this.context.textBaseline = 'hanging';
            }

            draw() {
                this.context.clearRect(0, 0, this.width, this.height);
                for (let i = 0; i <= this.DIMENSION; i++) {
                    for (let j = 0; j <= this.DIMENSION; j++) {
                        if (i != this.DIMENSION && j != this.DIMENSION) {
                            this.context.strokeRect((i + 1) * this.SIZE, (j + 1) * this.SIZE, this.SIZE, this.SIZE);
                            this.context.fillStyle = 'coral';
                            this.context.fillRect((i + 1) * this.SIZE, (j + 1) * this.SIZE, this.SIZE, this.SIZE);
                        }
                        if (this.state[i][j] == 1) {
                            //player: 1  black
                            const x = (i + 1) * this.SIZE;
                            const y = (j + 1) * this.SIZE;
                            this.context.beginPath();
                            this.context.arc(x, y, this.QIZI, 0, 2 * Math.PI);
                            this.context.closePath();
                            const rg = this.context.createRadialGradient(x, y, 0, x, y, this.QIZI);
                            rg.addColorStop(0, 'rgba(100,100,100,1)');
                            rg.addColorStop(0.7, 'rgba(40,40,40,1)');
                            rg.addColorStop(1, 'rgba(0,0,0, 1)');
                            this.context.fillStyle = rg;
                            this.context.fill();
                        } else if (this.state[i][j] == 2) {
                            //player: 2  white
                            const x = (i + 1) * this.SIZE;
                            const y = (j + 1) * this.SIZE;
                            this.context.beginPath();
                            this.context.arc(x, y, this.QIZI, 0, 2 * Math.PI);
                            this.context.closePath();
                            const rg = this.context.createRadialGradient(x, y, 0, x, y, this.QIZI);
                            rg.addColorStop(0, 'rgba(255,255,255,1)');
                            rg.addColorStop(0.7, 'rgba(220,220,220,1)');
                            rg.addColorStop(1, 'rgba(180,180,180, 1)');
                            this.context.fillStyle = rg;
                            this.context.fill();
                        }
                    }
                }
            }
            move(i, j) {
                console.log("player>>>", this.player, i, j);
                this.state[i][j] = this.player;
                this.player = this.player > 1 ? 1 : 2;
                this.draw();
                if (this.isGameOver()) {
                    alert(`Game over! ${this.player == 2? 'black' : 'white'} win`)
                    this.gameOver = true;
                }
            }
            eventHandle(dom) {
                dom.addEventListener("click", (evt) => {
                    let x = evt.pageX - this.dom.offsetLeft - this.SIZE;
                    let y = evt.pageY - this.dom.offsetTop - this.SIZE;
                    let i = Math.round(x / this.SIZE);
                    let j = Math.round(y / this.SIZE);
                    console.log(i, j);
                    if (i <= this.DIMENSION && j <= this.DIMENSION && !this.gameOver) {
                        this.move(i, j)
                    }
                });
            }
            isLegalMove() {

            }
            isGameOver() {
                //纵向
                let last = -1;
                let count = 0;
                for (let i = 0; i <= this.DIMENSION; i++) {
                    last = -1;
                    count = 0;
                    for (let j = 0; j <= this.DIMENSION; j++) {
                        if (count == 4) {
                            return true;
                        } else if (this.state[i][j]) {
                            if (this.state[i][j] == last) {
                                count++;
                            } else {
                                count = 0;
                                last = this.state[i][j];
                            }
                        } else {
                            count = 0;
                            last = -1;
                        }
                    }
                    if (count == 4) {
                        return true;
                    }
                }
                //横向
                for (let i = 0; i <= this.DIMENSION; i++) {
                    last = -1;
                    count = 0;
                    for (let j = 0; j <= this.DIMENSION; j++) {
                        if (count == 4) {
                            return true;
                        } else if (this.state[j][i]) {
                            if (this.state[j][i] == last) {
                                count++;
                            } else {
                                count = 0;
                                last = this.state[i][j];
                            }
                        } else {
                            count = 0;
                            last = -1;
                        }
                    }
                    if (count == 4) {
                        return true;
                    }
                }
                //斜45度
                for (let i = 0; i <= this.DIMENSION; i++) {
                    last = -1;
                    count = 0;
                    let x = this.DIMENSION - i;
                    let y = 0;
                    while (x >= 0 && y <= i) {
                        if (count == 4) {
                            return true;
                        } else if (this.state[x][y]) {
                            if (this.state[x][y] == last) {
                                count++;
                            } else {
                                count = 0;
                                last = this.state[x][y];
                            }
                        } else {
                            count = 0;
                            last = -1;
                        }
                        x--;
                        y++;
                    }
                    if (count == 4) {
                        return true;
                    }

                    last = -1;
                    count = 0;
                    x = i;
                    y = this.DIMENSION;
                    while (x <= this.DIMENSION && y >= 0) {
                        if (count == 4) {
                            return true;
                        } else if (this.state[x][y]) {
                            if (this.state[x][y] == last) {
                                count++;
                            } else {
                                count = 0;
                                last = this.state[x][y];
                            }
                        } else {
                            count = 0;
                            last = -1;
                        }
                        x++;
                        y--;
                    }
                    if (count == 4) {
                        return true;
                    }
                }

                // //斜-45度
                // for (let i = 0; i < this.DIMENSION; i++) {
                //     last = -1;
                //     count = 0;

                //     let x = i;
                //     let y = 0;
                //     while (x >= 0 && y <= i) {
                //         if (count == 4) {
                //             return true;
                //         } else if (this.state[y][x]) {
                //             if (this.state[y][x] == last) {
                //                 count++;
                //             } else {
                //                 count = 0;
                //                 last = this.state[y][x];
                //             }
                //         } else {
                //             count = 0;
                //             last = -1;
                //         }
                //         x--;
                //         y++;
                //     }
                // }
                return false
            }
        }
    </script>

    <script type="text/javascript"">
        new Vue({
            el: '#app',
            data() {},
            methods: {},
            mounted() {
                let game = new Game(this.$refs.canvas);
                game.move(1, 1);
            }
        });
    </script>
</body>

</html>